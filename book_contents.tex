\author{Nicky D. van  Foreest}

\begin{document}
\frontmatter
\maketitle

\tableofcontents

\chapter{Introduction}\label{sec:introduction}
%\addcontentsline{toc}{chapter}{Introduction}

\input{tex_files/intro.tex}

\mainmatter

\chapter{Construction and Simulation of Queueing Systems}
\label{cha:single-stat-queu}

In this chapter we start with a discussion of the Poisson process.
We then construct queueing processes in discrete time and apply the Poisson process to model the number of arrivals in periods of fixed length.
In~\cref{sec:expon-distr} we relate the exponential distribution to the Poisson distribution.
The exponential distribution often serves as a good model for inter-arrival times of individual jobs.
As such this is a key component of the construction of queueing processes in continuous time.
As it turns out, both ways to construct queueing processes are easily implemented as computer programs, thereby allowing us to use simulation to analyze queueing systems.
In passing we develop a number of performance measures to provide insight into the (transient and average) behavior of queueing processes.

We assume that you  \emph{know all} results of~\cref{sec:preliminaries}. 

\input{tex_files/preliminaries.tex}
\input{tex_files/poissondistribution.tex}
\input{tex_files/constructiondiscretetime.tex}
\input{tex_files/expdistribution.tex}
\input{tex_files/constructioncontinuoustime.tex}


\chapter{Analytical Models}
\label{cha:analytical-models}

In this chapter we focus on developing analytic models for various queueing systems in steady-state.
In the analysis we use sample-path and level-crossing arguments to count how often certain events occur as a function of time.
Then we define probabilities in terms of limits of fractions of these counting processes.
Like this the performance measures can be explicitly computed for the statistical analysis of (simulations of) queueing systems.

We start with developing a useful set of shorthands to distinguish between different queueing models. Then we include a section to motivate why we focus on a steady-state analysis of queueing systems. 

As a reminder, we keep the discussion in these notes mostly at an intuitive level, and refer to \cite{el-taha98:_sampl_path_analy_queuein_system} for proofs and further background.

\input{tex_files/kendall.tex}
\input{tex_files/random_walk.tex}
\input{tex_files/ratestability.tex}
\input{tex_files/renewal_reward.tex}
\input{tex_files/empiricalperfmeasures.tex}
\input{tex_files/levelcrossing.tex}
\input{tex_files/mm1.tex}
\input{tex_files/mnmn1.tex}
\input{tex_files/pasta.tex}
\input{tex_files/little.tex}
\input{tex_files/mxm1_pk.tex}
\input{tex_files/mg1.tex}
\input{tex_files/batcharrivals.tex}
\input{tex_files/mg1distributionqueuelength.tex}
% \input{tex_files/relationmxm1andmg1.tex}
%\input{tex_files/mg1density.tex}
\input{tex_files/figure_summaries.tex}


\chapter{Approximate Models}
\label{cha:approximate-models}
In this chapter we first consider the very useful formula of Sakasegawa to approximate the average waiting time in queue for the $G/G/c$ queue.
We then illustrate how to use this formula to estimate waiting time in three examples in which the server is interrupted.
In the first case the server has to produce jobs from different families, and there is a switch-over time required to change the production family.
Such setups reduce the time the server has available to serve jobs.
To reduce the load the server produces in batches of fixed sizes.
In the second case, the server sometimes requires a small adjustment, for instance, to prevent its quality to degrade below a certain level.
Such adjustments are not necessary to perform during a job's service, however, they can occur at arbitrary moments in time.
Thus, this is different from batch production in which the batch sizes (the number of jobs served between two interruptions) are constant.
In the third example, quality problems or break downs can occur during a job's service.
For each case we develop a model to analyze the influence of the interruption duration and frequency on average waiting times. 

\input{tex_files/gg1.tex}
\input{tex_files/setup_times.tex}
\input{tex_files/adjustments.tex}
\input{tex_files/failures.tex}
%\input{tex_files/process_batches.tex}


\chapter{Queueing Networks}
\label{sec:notes-relat-chapt2}

We refer to the relevant sections of Zijm's book for background. Here we just include the solutions and repair a few typos. 
\input{tex_files/open_single_class.tex}
\input{tex_files/tandem.tex}
%\input{tex_files/open_general.tex}

%\input{tex_files/deterministic_networks.tex}
\input{tex_files/gordon_newell.tex}
%\input{tex_files/convolution.tex}
\input{tex_files/mva.tex}
%\input{tex_files/mda.tex}


\backmatter

\addcontentsline{toc}{chapter}{Bibliography}
\phantomsection
\bibliographystyle{plainnat}
\bibliography{biblio_nicky}


\chapter{Notation}
\label{sec:notation}
%\addcontentsline{toc}{chapter}{Notation}
\input{tex_files/notation.tex}

\chapter{Formula Sheet}
%\addcontentsline{toc}{chapter}{Formula Sheet}
\input{tex_files/formula_sheet.tex}

\addcontentsline{toc}{chapter}{Index}
\phantomsection
\printindex

\end{document}
