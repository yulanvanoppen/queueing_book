%\section{Construction of Discrete-Time  Queueing Processes}
\section{Construction of Discrete-Time Queueing
  Processes}
\label{sec:constr-discr-time}

\subsection*{Theory}

\Opensolutionfile{hint}
\Opensolutionfile{ans}


To provide real-life motivation to analyze queueing systems we discuss a case.  As this case is too hard to analyze by mathematical means,  we need to develop a model to simulate the queueing system in discrete time.  Interestingly, the structure of the simulation is very simple so that  it is also  an exceedingly convincing tool to communicate the results of an analysis of a queueing system to managers (and the like).  

Let us start with discussing the essentials of the simulation of a queueing system. The easiest way  to construct queueing processes is to `chop up' time in periods and develop recursions for the behavior of the queue from period to period. Note that the length of such a period depends on the
case for which the model is developed.  For instance, to study queueing processes at a supermarket, a period can consist of $5$ minutes, while for a production environment, e.g., a job shop, it can
be a day, or even a week.

Using fixed sized periods has the advantage that we do not have to
specify specific inter-arrival times or service times of individual
customers. Only the number of arrivals in a period and the number of
potential services are relevant, which is useful since in many
practical settings, e.g., production environments, it is easier to
provide data in these terms than in terms of inter-arrival and service
times. 

Let us define:
\begin{equation}
  \label{eq:30}
  \begin{split}
    a_k &= \text{number of jobs that arrive at period $k$},\\
    c_k &= \text{the capacity, i.e., the maximal number of jobs that can be served, during period $k$},\\
    d_k &= \text{number of jobs that depart the queue  \textit{in} period $k$},\\
    Q_k &= \text{number of jobs in queue  at the \textit{end} of period $k$}.\\
  \end{split}
\end{equation}
In the sequel we also call $a_k$ the size of the batch arriving in
period $k$. The definition of $a_k$ is a bit subtle: we may assume
that the arriving jobs arrive either at the start or at the end of the
period. In the first case, the jobs can be served in period $k$,
in the latter case, they \emph{cannot} be served in period~$k$.


Let  $Q_{k-1}$ be the queue length at the end of period $k-1$, it
must also be the queue length at the start of period $k$. Assuming
that jobs arriving in period $k$ cannot be served in period~$k$,
the number of customers that depart from the queue in period $k$
is
\begin{subequations}\label{eq:31}
\begin{equation}\label{eq:d_k}
d_k = \min\{Q_{k-1}, c_k\},
\end{equation}
since only the jobs that are present at the start of the period, i.e.,
$Q_{k-1}$, can be served if the capacity exceeds the queue length. Now
that we know the number of departures, the queue at the end of period
$k$ is given by
\begin{equation}
    Q_k = Q_{k-1} -d_k + a_k.
\end{equation}
\end{subequations}
Like this, if we are given $Q_0$,  we can obtain $Q_1$, and from this  $Q_2$, and so on.

Note that in this type of queueing system there is not a job in service, we only count the jobs in the system at the end of a period. Thus, the number of jobs in the system and in queue coincide; in this section `queue length' henceforth means the number of jobs in the system.

\begin{exercise}
Suppose that $c_k= 7$ for all $k$, and $a_1=5$, $a_2=4$
and $a_3=9$; also $Q_0=8$. What are $d_k$ and $Q_k$ for $k\geq 1$? 
\begin{solution}
$d_1=7$, $Q_1=8-7+5=6$, $d_2 = 6$,
$Q_2=6-6+4=4$, $d_3 = 4$, $Q_3=4-4+9=9$, and so on. 
\end{solution}
\end{exercise}

\begin{exercise}
 What is the interpretation of setting
    $d_k = \min\{Q_{k-1}+a_k,  c_k\}$ rather than definition~\eqref{eq:d_k}?
\begin{solution}
 The assumption is that the jobs arrive at the start of period
    $k$, before service in period $k$ starts, rather than at the end
    of the period. Therefore the arrivals at period $k$ can also be
    served during period $k$.
\end{solution}
\end{exercise}


Of course we are not going to carry out these computations by
hand. Typically we use company data about the sequence of arrivals
$\{a_k\}_{k=1,2,\ldots}$ and the capacity $\{c_k\}_{k=1,\ldots}$ and
feed this data into a computer to carry out the
recursions~\eqref{eq:31}. If we do not have sufficient data we make a
probability model for these data and use the computer to generate
random numbers with, hopefully, similar characteristics as the real
data. At any rate, from this point on we assume that it is easy, by
means of computers, to obtain numbers $a_1,\ldots, a_n$ for
$n\gg 1000$, and so on.


\begin{exercise}
  Implement Eqs.~\ref{eq:31} in python and simulate a
  simple single-server queueing system. Assume that the $a_k \sim P(20)$, i.e., Poisson distributed with $\lambda=20$, and $c_k =\mu=21$. Make a plot of the queue length process $Q$, and compute the mean and standard variance of $Q$. Compute the fraction of periods in which the queue length exceeds some threshold, 20, say. 
  \begin{solution}
    Below I fix the seed of the random number generator to ensure that
    I always get the same results from the simulator.  The arrival
    process is Poisson, and the number of services is fixed to 21 per
    period. I use \pyv{Q = np.zeros\_like(a)} to make an array of the
    same size as the number of arrival $a$ initially set to zeros. The
    rest of the code is nearly identical to the formulas in the text.

\begin{pyconsole}
import numpy as np

np.random.seed(3) # fix the seed

labda = 20
mu = 21
\end{pyconsole}

These are the number of arrivals in each period.

\begin{pyconsole}
a = np.random.poisson(labda, 10)
a
\end{pyconsole}

The number of potential services
\begin{pyconsole}
c = mu * np.ones_like(a)
c
\end{pyconsole}

Now for the queueing recursions:

\begin{pyconsole}
Q = np.zeros_like(a)
d = np.zeros_like(a)
Q[0] = 10  # initial queue length

for k in range(1, len(a)):
    d[k] = min(Q[k - 1], c[k])
    Q[k] = Q[k - 1] - d[k] + a[k]

\end{pyconsole}

Here are the departures and queue lengths for each period:
\begin{pyconsole}
d
Q
\end{pyconsole}


Suppose we define loss as the number of periods in which the queue length exceeds
20. Of course, any other threshold can be taken. Counting the number
of such periods is very easy in python: \pyv{(Q>20)} gives all
entries of $Q$ such $Q>20$, the function \pyv{sum()} just adds
them. 

\begin{pyconsole}
loss = (Q > 20)
loss
loss.sum()
\end{pyconsole}

Now all statistics:

\begin{pyconsole}
d.mean()
Q.mean()
Q.std()
(Q > 20).sum()
\end{pyconsole}
  

Since this is a small example, the mean number of departures, i.e.,
\pyv{d.mean()}, is not equal to the arrival rate $\lambda$.  
Likewise for the computation of the mean, variance, and other
statistical functions. 

Now I am going to run the same code, but for a larger instance. 

\begin{pyconsole}
num = 1000
a = np.random.poisson(labda, num)
c = mu * np.ones_like(a)
Q = np.zeros_like(a)
d = np.zeros_like(a)
Q[0] = 10  # initial queue length

for k in range(1, len(a)):
    d[k] = min(Q[k - 1], c[k])
    Q[k] = Q[k - 1] - d[k] + a[k]

d.mean()
Q.mean()
Q.std()
(Q > 30).sum()/num * 100
\end{pyconsole}


I multiply with 100 to get a percentage. Clearly, many jobs see a long
queue, the mean is already some 28 jobs. For this arrival rate a
service capacity of $\mu=21$ is certainly too small. 


Hopefully you
understand from this discussion that once you have the recursions to
construct/simulate the queueing process, you are `in business'. The
rest is easy: make plots, do some counting, i.e., assemble statistics,
vary parameters for sensitivity analysis, and so on.


\end{solution}
\end{exercise}


\begin{exercise}
  Change the service process of the previous exercise from $c_k =\mu=21$ to $c_k\sim P(\mu)$ with $\mu=21$. What is the influence of the higher variability of the service process on the queue length? 
  \begin{solution}
In this  example the number of jobs served per day is $\sim P(21)$, so the service rate is
still $21$, but the period capacity $c$ is a Poisson random variable. 

\begin{pyconsole}
c = np.random.poisson(mu, num)
Q = np.zeros_like(a)
d = np.zeros_like(a)
Q[0] = 10  # initial queue length

for k in range(1, len(a)):
    d[k] = min(Q[k - 1], c[k])
    Q[k] = Q[k - 1] - d[k] + a[k]

d.mean()
Q.mean()
Q.std()
(Q > 30).sum()/num * 100
\end{pyconsole}

Comparing this to the result of the previous exercise in which the service capacity in each period was constant $c=21$, we see that the average waiting time increases, just as the number of periods in which the queue length exceeds 30.
Clearly, variability in service capacity does not improve the performance of the queueing system, quite on the contrary, it increases.
In later sections we will see why this is so.
  \end{solution}
\end{exercise}

\subsection*{Case}
\label{sec:case}



We now show how to apply~\eqref{eq:30} and~\eqref{eq:31} to a real case. At a mental health department five psychiatrists do intakes of future
patients to determine the best treatment process for the patients.
There are complaints about the time patients have to wait for their
first intake; the desired waiting time is around two weeks, but the
realized waiting time is sometimes more than three months. The
organization considers this is to be unacceptably long, but\ldots what to do about it?

To reduce the waiting times the five psychiatrists have various
suggestions. 
\begin{enumerate}
\item Not all psychiatrists have the same amount of time available per
  week to do intakes. This is not a problem during weeks when all psychiatrists are
  present; however, psychiatrists tend to take holidays, visit
  conferences, and so on. So, if the psychiatrist with the most
  intakes per week would go on leave, this might affect the behavior
  of the queue length considerably. This raises the question about the difference
  in allocation of capacity allotted to the psychiatrists. What are
  the consequences on the distribution and average of the waiting
  times if they would all have the same weekly capacity?
\item The psychiatrists tend to plan their holidays after each
  other, to reduce the variation in the service capacity. What if they
  would synchronize their holidays, to the extent possible, rather
  than spread their holidays? 
\item Finally, suppose the psychiatrists would do 2 more intakes per
  week in busy times and 2 fewer in quiet weeks. Assuming that the
  system is stable, i.e., the average service capacity is larger than the average demand,
  then on average the psychiatrists would not do more intakes, i.e.,
  their workload would not increase, but the queue length may be
  controlled better.
\end{enumerate}


To evaluate the effect of these suggestions on reducing the queueing
dynamics we develop a simple simulator with which we can make a number of plots. 
As a first step we model the arrival process of patients as a Poisson
process, c.f., Section~\ref{sec:poisson-distribution}. The duration of
a period is taken to be a week. The average number of arrivals per
period, based on data of the company, was slightly less than~12 per
week; in the simulation we set it to $\lambda= 11.8$ per week. We
model the capacity in the form of a matrix such that row $i$
corresponds to the weekly capacity of psychiatrist $i$:
\begin{equation*}
C = 
  \begin{pmatrix}
    1 & 1 & 1 & \ldots\\
    1 & 1 & 1 & \ldots\\
    1 & 1 & 1 & \ldots\\
    3 & 3 & 3 & \ldots\\
    9 & 9 & 9 & \ldots\\
  \end{pmatrix}.
\end{equation*}
Thus, psychiatrists 1, 2, and 3 do just one intake per week, the
fourth does 3, and the fifth does 9 intakes per week. The sum over
column $k$ is the total service capacity for week $k$ of all
psychiatrists together.

With the matrix $C$ it is simple to make other capacity schemes. A
more balanced scheme would be like this:
\begin{equation*}
C = 
  \begin{pmatrix}
    2 & 2 & 2 & \ldots\\
    2 & 2 & 2 & \ldots\\
    3 & 3 & 3 & \ldots\\
    4 & 4 & 4 & \ldots\\
    4 & 4 & 4 & \ldots\\
  \end{pmatrix}.
\end{equation*}

We next include the effects of holidays on the capacity. This is
easily done by setting the capacity of a certain psychiatrist to 0 in
a certain week. Let's assume that just one psychiatrist is on leave in
a week, each psychiatrist has one week per five weeks off, and the
psychiatrists' holiday schemes rotate. To model this, we set
$C_{1,1,}=C_{2,2}=\cdots=C_{1,6}=C_{2,7} =\cdots = 0$, i.e.,
\begin{equation*}
C = 
  \begin{pmatrix}
    0 & 2 & 2 & 2 & 2 & 0 & \ldots \\
    2 & 0 & 2 & 2 & 2 & 2 & \ldots\\
    3 & 3 & 0 & 3 & 3 & 3 & \ldots\\
    4 & 4 & 4 & 0 & 4 & 4 & \ldots\\
    4 & 4 & 4 & 4 & 0 & 4 & \ldots\\
  \end{pmatrix}.
\end{equation*}
Hence, the total average capacity must be $4/5 \cdot (2+2+3+4+4) = 12$
patients per week.  The other holiday scheme---all psychiatrists take
holiday in the same week--corresponds to setting entire columns to
zero, i.e., $C_{i,5}=C_{i,10}=\cdots=0$ for week $5$, $10$, and so
on. Note that all these variations in holiday schemes result in the
same average capacity.

Now that we have modeled the arrivals and the capacities, we can use
the recursions~\eqref{eq:31} to simulate the queue length process for
the four different scenarios proposed by the psychiatrists, unbalanced
versus balanced capacity, and spread out holidays versus simultaneous
holidays.  The results are shown in Figure~\ref{fig:balanced}. It is
apparent that suggestions 1 and 2 above do not significantly affect
the behavior of the queue length process.  



\begin{figure}[ht]
  \centering
% progs/intake_control.py
\input{progs/balanced} 
\caption{Effect of capacity and holiday plans. We plot for each time point
  the maximum and the minimum queue length for each of the
  policies. Apparently, the effect of each of these policies is, for
  all practical purposes, negligible.  }
\label{fig:balanced}
\end{figure}


Now we consider suggestion 3, which comes down to doing more intakes
when it is busy, and fewer when it is quiet. A simple rule to
implement this is by considering last week's queue $Q_{n-1}$: if
$Q_{n-1}<12$, i.e., the service capacity of one week, then do $e$
intakes less. Here, $e=1$ or $2$, or perhaps a larger number; it
corresponds to the amount of control we want to exercise. When
$Q_{n-1}>24$, i.e., larger than two weeks of intakes, do $e$ intakes
more. Let's consider three different control levels, $e=1$, $e=2$, and
$e=5$; thus in the last case all psychiatrists do five extra intakes.
The previous simulation shows that it is safe to disregard the holiday
plans, so just assume a flat service capacity of 12 intakes a week.

Figure~\ref{fig:intakes} shows a striking difference indeed. The queue
does not explode any more, and already taking $e=1$ has a large
influence. 

\begin{figure}[ht]
  \centering
% progs/intake_control.py
\input{progs/service_control.tex}  
\caption{Controlling the number of intakes. Clearly, adapting the
  service rate `does wonders' to control the queue length.}
\label{fig:intakes}
\end{figure}

From this simulation experiment we learn that changing holiday plans or
spreading the work over multiple servers, i.e., psychiatrists, does
not significantly affect the queueing behavior.  However, controlling
the service rate as a function of the queue length improves the
situation quite dramatically. 


Observe that, even with these (deceitfully) simple recursions, we can obtain
considerable insight into this, otherwise, very complicated controlled
queueing process. (If the reader doubts the value of simulation, s/he
should try to develop other mathematical methods to analyze
multi-server queueing systems with vacations, of which this case is an
example.) As a matter of fact, with such simple recursions we can analyze many practical queueing
situations. Together with students the author applied it numerous
times, for instance,
\begin{itemize}
\item Should a certain hospital invest in a new MRI scanner to reduce
  waiting times?
\item When to switch on and off a tin bath at an electronics component factory?
\item How to route post parcels in a post sorting center.
\end{itemize}

In general, the study of queueing system is focused on
studying the probabilistic properties of the queueing length process
and related concepts such as waiting time, server occupancy, fraction
of customers lost, and so on. Once we have constructed the queueing
process we can compute all performance measures of relevance, such as
the average waiting time. If it turns out that the
performance of the system is not according to what we desire, we can
change parts of the system with the aim to improve the situation and
assess the effect of this change.  For instance, if the average
waiting time is too long, we might add service capacity. With simulation it is easy to study the effect of, hence
evaluate, such decisions.

\subsection*{Exercises}
\label{sec:exercises-1}


The reader should understand from the above case that, once we have
the recursions, we can analyze the system and make plots to evaluate
suggestions for improvement.  Thus, getting the recursions is crucial
to construct, i.e., model, queueing processes. For this reason, most
of the exercises below focus on obtaining recursions for many
different queueing systems. 

A comment is required about the modeling exercises below. It may be
that the recursions you find are not identical to the recursions in
the solution; the reason is that the assumptions you make might not be
equal to the ones I make. I don't quite know how to get out of this
paradoxical situation.  In a sense, to completely specify the model,
we need the recursions. However, if the problem statement would
contain the recursions, there would be nothing left to practice
anymore. Another way is to make the problem description five times as
long, but this is also undesirable. So, let's be pragmatic: the aim is
that you practice with modeling, and that you learn from the
solutions.  If you obtain \emph{reasonable} recursions, but they are
different from mine, then your answer is just as good.

\begin{exercise} (Queue with Blocking) Consider a queueing system
  under daily review, i.e., at the end of the day the queue length is
  measured. We assume that at the end of the day no jobs are still in
  service. We assume that jobs that arrive at day $k$ cannot be served
  in day $k$. The queue length cannot exceed level $K$.  Formulate a
  set of recursions to cover this case. What is the loss per period? What is the fraction of jobs lost?
  \begin{solution}

    All jobs that arrive such that the queue become larger than $K$
    must be dropped. 

First $d_k = \min\{Q_{k-1}, c_k\}$. Then, $Q_k' = Q_{k-1}+a_k-d_k$ is the queue without blocking. Then $Q_k=\min\{Q_k', K\}$ is the queue with blocking. Finally, the loss $l_k=Q_k'-Q_k$, i.e., the excess arrivals. The fraction lost is $l_k/a_k$. 
  \end{solution}
\end{exercise}

\begin{exercise}\label{ex:19} (Estimating the lead time distribution.)  Take
  $d_k = \min\{Q_{k-1}+a_k, c_k\}$, and assume that jobs are served in
  FIFO sequence. Find an expression for the shortest possible waiting
  time $W_-(k)$ of a job that arrives at time $k$, and an expression
  for the largest possible waiting time $W_+(k)$
  \begin{hint}
  Consider a numerical example. Suppose $Q_{k-1}=20$. Suppose
    that the capacity is $c_k=3$ for all $k$. Then a job that arrives
    in the $k$th period, must wait at least $20/3$ (plus rounding)
    periods before it can leave the system. Now generalize this
    numerical example.
  \end{hint}
    \begin{solution}
      Let's tag the first customer that arrives in period $k$. This
      tagged customer sees $Q_{k-1}$ customers in the system, hence the
      tagged customer's service can only start after all $Q_{k-1}$
      customers have been served (assuming FIFO scheduling of course).  Now, if $Q_{k-1}-c_k \geq 0$, there are
      still people in front of the tagged customer, either in queue or in service. In fact, as long
      as $c_k+c_{k+1}+\cdots +c_m \leq Q_{k-1}$, there are still customers in
      front of the tagged customer. Therefore, when the tagged customer leaves the system, the inequality $c_k+c_{k+1}+\cdots +c_m > Q_{k-1}$ must hold.

      We can also tag the last customer that arrives in period
      $k$. This customer will certainly have left if $m$ is such that
      $c_k+\cdots+c_m \geq Q_{k-1}+a_k$.

      In formulas the above comes down to the following.  A job that
      arrives in period $k$ cannot be served before period
    \begin{equation*}
    W_{-,k}:= \min\left\{m: \sum_{i=k}^{k+m} c_i > Q_{k-1}\right\},
    \end{equation*}
    and it must have been served before period
    \begin{equation*}
      W_{+,k}:= \min\left\{m: \sum_{i=k}^{k+m} c_i \geq
        Q_{k-1}+a_k\right\}.
    \end{equation*}
    Thus, the waiting time of jobs arriving in period $k$ must lie in
    the interval $[W_{-,k}, W_{+,k}]$.
  \end{solution}
\end{exercise}

\begin{exercise}
  (Yield loss) A machine produces items, but a fraction $p$ of the
  items produced in a period turns out to be faulty, and has to be
  made anew. Develop a set of recursions to cover this case.
  \begin{solution}
    The amount produced in period $k$ is $d_k$. Thus, $p d_k$ is the
    amount lost, neglecting rounding errors for the moment. Thus,
    $p d_k$ items have to be fed back to the system in the next period
    to be remade. Therefore the total amount of arrivals in period
    $k+1$ is $a_{k+1}'=a_{k+1}+pd_k$, i.e., the external arrivals plus
    the extra items. Now use the standard recursions but with the
    $\{a_{k}'\}$ rather than $\{a_k\}$.

    Can you use these recursions to show that the long-run average
    service capacity $n^{-1}\sum_{i=1}^n c_i$ must be larger than
    $\lambda(1+p)$?

    If you like you can incorporate time-dependent failure rates
    $\{p_k\}$ too. Whether this makes practical sense depends on the
    context of course.
      \end{solution}
\end{exercise}

\begin{exercise}
  (Rework) A machine produces items, but a fraction $p$ of the items
  does not meet the quality requirements after the first service but
  need some extra service time but less than an entirely new arriving
  job. Make a model to analyze this case. Compare this case with the
  yield loss problem above. 

  Let's assume that the repair of a faulty requires half of the work
  of a new job, and that the faulty jobs are processed with priority
  over the new jobs.  Also assume that faulty items do not need more than one repair (hence, faulty items that are repaired cannot be faulty anymore).

There are of course many different policies to
  treat rework.   Another possibility is that faulty items are processed at the end of
  the day. Yet another possibility is that faulty items are collected
  until there are $N$, say, and then the entire batch of $N$ is
  repaired.
  \begin{solution}
    Suppose again that a fraction $p$ is faulty. Since these faulty
    items require less processing time than a new job, the service
    capacity $c_k$, i.e., the number of jobs that can be processed in
    period $k$, is a bit bigger; part of the capacity is spent on new
    jobs but another part is spent on the faulty jobs. By the
    assumptions above, the repair of a faulty requires half of the
    work of a new job, and the faulty jobs are processed with priority
    over the new jobs. Assume queue $A$ contains the faulty items, and
    queue $B$ the new jobs. Then the recursions become:
\begin{equation*}
  \begin{split}
    d_{k,A} &= \min\{Q_{k-1, A}, 2c_k\}, (\text{ as faulty jobs require half of the processing time})\\
    c_{k,B} &= c_k - d_{k,A}/2, \\
    d_{k,B} &= \min\{Q_{k-1, B}, c_{k,B}\}, \\
    a_{k,A} &= p d_{k-1, B}, \\
    Q_{k,A} &= Q_{k-1, A} + a_{k,A} - d_{k,A}, \\
    Q_{k,B} &= Q_{k-1, B} + a_{k,B} - d_{k,B}.
  \end{split}
\end{equation*}
  \end{solution}
\end{exercise}


\begin{exercise}(Cost models) A single-server queueing station
  processes customers. At the start of a period the server capacity is
  chosen, so that for period $k$ the capacity is $c_k$. Demand that
  arrives in a period can be served in that period. It costs $\beta$
  per unit time per unit processing capacity to operate the machine,
  i.e., to have it switched on. There is also a cost $h$ per unit time
  per job in the system. Make a cost model to analyze the long-run
  average cost for this case.
  \begin{solution}
First consider the dynamics of the queue. Since the capacity is chosen at the start of the period (the machine is switched on for $c_k$ units even if there is less demand):
\begin{align*}
  d_k &= \min\{Q_{k-1}+a_k, c_k\} \\
Q_k &= Q_{k-1}+a_k - d_k.
\end{align*}
The cost to operate the server during period $k$ is $\beta c_k$.
Thus, the total cost up to some time $T$ for the server must be
$\beta \sum_{k=1}^T c_k$. In period $k$ we also have to pay $h Q_k$,
since $h$ is the cost per customer per period in the system. Thus, the
long-run average cost is
    \begin{equation*}
      \frac 1T\sum_{k=1}^T \left(\beta c_k + h Q_k\right).
    \end{equation*}

    It is an interesting problem to find a policy that minimizes (the
    expectation of) this cost. The policy is such that the capacity
    for period $k$ can be chosen based on the queue length $Q_{k-1}$
    and \emph{estimates} of the demands
    $\hat d_k, \hat d_{k+1}, \ldots$. This problem is not easy, as far as I can see. 

  \end{solution}
\end{exercise}

\begin{exercise}(N-policies) A machine can switch on and off. If the
  queue length hits $N$, the machine switches on, and if the system
  becomes empty, the machine switches off. It costs $K$ to switch on
  the machine. There is also a cost $\beta$ per unit time while the
  machine is switched on, and it costs $h$ per unit time per customer
  in the system. Make a cost model. 
  \begin{solution}
    First we need to implement the N-policy. For this we need an extra
    variable to keep track of the state of the server. Let $I_k=1$ if the machine is on in period $k$ and $I_k=0$ if it is off. Then $\{I_k\}$ must satisfy the relation
    \begin{equation*}
      I_{k+1} =
      \begin{cases}
        1 & \text{ if } Q_{k} \geq N,\\
        I_k & \text{ if } 0< Q_{k} <N,\\
        0 & \text{ if }  Q_{k} =0,\\
      \end{cases}
    \end{equation*}
and assume that $I_0 =0$ at the start, i.e., the machine if off. Thus, we can write:
\begin{equation*}
  I_{k+1} = \1{Q_k\geq N} + I_k \1{0<Q_k<N} + 0\cdot \1{Q_k = 0}.
\end{equation*}
With $I_k$ it follows that $d_k =\min\{Q_{k-1}, I_k c_k\}$, from which
$Q_k$ follows, and so on.

The machine cost for period $k$ is $\beta I_k$, because only when the
machine is on we have to pay $\beta$, and the queueing cost is
$h Q_k$. To determine the total switching cost is harder as we need to
determine how often the machine has been switched on up to time
$T$. Observe that the machine is switched on in period $k$ if
$I_{k-1} = 0$ and $I_k=1$. Thus, whenever $I_k - I_{k-1}=1$ the
machine is switched on, when $I_k - I_{k-1}=0$ the state of the
machine remains the same, and if $I_k - I_{k-1} = -1$ the machine is
switched off. In other words $\max\{I_k - I_{k-1},0\}$ captures what
we need. The total cost up to time $T$ becomes:
\begin{equation*}
  \sum_{k=1}^T \left(\beta I_k + h Q_k + K\max\{I_k - I_{k-1}, 0\}\right).
\end{equation*}
  \end{solution}
\end{exercise}




\begin{exercise}
  How would you model (in terms of recursions) a server whose capacity
  depends on the queue length? Consider, as an example, a rule such
  that the server only works if the queue is larger than a threshold $t$. 
  \begin{solution}
    One model could be to let the server only switch on when the queue
    is larger than some threshold $t$, and when the server is on, it
    works at rate $c$ per period. In that case,
    $c_k = c\1{Q_{k-1} > t}$.
  \end{solution}
\end{exercise}

\begin{exercise}(Fair queueing) One server serves two queues. Each
  queue receives service capacity in proportion to its queue length. Derive a set of recursions to analyze this situation.
  \begin{solution}
    Let $c_k^i$ be the capacity allocated to queue $i$ in period $k$. The fair rule gives that 
    \begin{equation*}
      c_k^1 = \frac{Q_{k-1}^1}{Q_{k-1}^1 + Q_{k-1}^2} c = c - c_k^2. 
    \end{equation*}
Then, 
\begin{equation*}
  \begin{split}
      d_k^1 &= \min\{Q_{k-1}^1, c^1_k\}, \\
Q_k^1 &= Q_{k-1}^1+a_k^1  - d_k^1,
  \end{split}
\end{equation*}
and likewise for the other queue.
  \end{solution}
  \end{exercise}

  \begin{exercise} (Priority queuing) Another interesting situation is
    a system with two queues served by one server, but such that one
    queue, queue $A$, gets priority over the other
    queue. Again find a set of recursions to describe this case.
    \begin{solution}
      The rules below implement a strict priority rule for jobs of type
      A, i.e., jobs sent into queue A.
\begin{equation*}
  \begin{split}
    d_{k,A} &= \min\{Q_{k-1, A}, c_k\}, \\
    c_{k,B} &= c_k - d_{k,A}, \\
    d_{k,B} &= \min\{Q_{k-1, B}, c_{k,B}\}, \\
    Q_{k,A} &= Q_{k-1, A} + a_{k,A} - d_{k,A}, \\
    Q_{k,B} &= Q_{k-1, B} + a_{k,B} - d_{k,B}.
  \end{split}
\end{equation*}

As an aside, another interesting rule to distribute the capacity $c_k$
over the queues could be based on the principle of \textit{ equal
  division of the contested sum}. This principle is based on game
theoretic ideas. Aumann and Maschler applied this principle to clarify
certain division rules discussed in the Talmud to divide the legacy
among a number of inheritors, each having a different claim size.
    \end{solution}
\end{exercise}



\begin{exercise} 
  (Queues with reserved service capacity) Consider a single-server that
  serves two parallel queues $A$ and $B$. Each queue has a minimal service
  capacity every period, $r_A$ for queue $A$ and $r_B$ for queue $B$. Reserved capacity unused for one queue can be
  used to serve the other queue. Any extra capacity beyond the
  reserved capacity is given to queue A with priority. Formulate a set
  of recursions to analyze this situation.
  \begin{solution}
    First determine how much capacity queue $B$ minimally needs in
    period $k$:
    \begin{equation*}
      c_{k,B} = \min\{Q_{ k-1, B}, r_B\}.
    \end{equation*}
    Observe that, since $c_k \geq r_A + r_B$, this rule ensures that
    queue A receives at least its reserved capacity $r_A$. 

    Since queue A is served with priority, we first give all capacity,
    except what queue B minimally needs, to queue A:
    \begin{equation*}
d_{k,A} = \min\{Q_{k-1, A}, c_k-c_{k,B}\}.
\end{equation*}
And then we can give any left over capacity to queue B, if needed. 
\begin{align*}
d_{k,B} &= \min\{Q_{k-1, B}, c_k-d_{k,A}\}.
\end{align*}

    An example is the weekly capacity offered by a psychiatrist at a
    hospital. Part of the weekly capacity is
    reserved/allocated/assigned to serve certain patient groups. For
    instance, each week the psychiatrist does at most five intakes of
    new patients, provided there are any, and the rest of the capacity
    is used to treat other patients. The existing patients can also be
    divided in different groups, each receiving a minimal capacity. It
    there less patients of some group, then the capacity can be
    planned/given to other patient groups. 
  \end{solution}
\end{exercise}


\begin{exercise} 
  (Queue with protected service capacity, lost capacity) Consider a
  single-server that serves two parallel queues $A$ and $B$. Each queue receives a
  minimal service capacity every period. Reserved capacity unused for
  one queue cannot be used to serve the other queue. Any extra
  capacity beyond the reserved capacity is given to queue A with
  priority. Formulate a set of recursions to analyze this situation.

  Let $r_A$ be the reserved capacity for queue A, and likewise for
   $r_B$. We assume of course that $c_k\geq r_A + r_B$, for all $k$.
   \begin{solution} Queue A can use all capacity, except what is
     reserved for queue B:
\begin{equation*}
  d_{k,A} = \min\{Q_{A, k-1}, c_k - r_B\}.
\end{equation*}
Observe that, since $c_k \geq r_A + r_B$, this rule ensures that queue
A receives at least its reserved capacity $r_A$.

Queue $B$ cannot receive more than $c_k-r_A$, since $r_A$ is allocated
to queue A, and if queue $A$ does not use all of $r_A$, then the
surplus is lost. Also, queue $B$ cannot get more than $c_k - d_{k,A}$
as this is what remains after serving queue $A$. Thus, letting
$c_{k,B} = \min\{c_k-r_A, c_k-d_{k,A}\} = c_k - \max\{r_A, d_{k,A}\}$,
we see that for queue B:
\begin{equation*}
  d_{k,B} = \min\{Q_{B, k-1}, c_{k,B}\}.
\end{equation*}

An example can be the operation room of a hospital. There is a weekly
capacity, part of the capacity is reserved for emergencies. It might
not be possible to assign this reserved capacity to other patient
groups, because it should be available at all times for emergency
patients. A result of this is that unused capacity is lost.  

In practice it may not be as extreme as in the model, but still part
of the unused capacity is lost. `Use it, or lose it', is what often,
but not always, applies to service capacity.
  \end{solution}
\end{exercise}




\begin{exercise}(Tandem  networks) 
  Consider a production network with two production stations in
  tandem, that is, the jobs processed by station A are in the next
  period to the downstream Station B.  Extend the recursions of
  \eqref{eq:31} to simulate this situation.
\begin{solution}
  Let $a_k$ be the external arrivals at station A. Then:
\begin{equation}
  \begin{split}
    d^A_k &= \min\{Q_{k-1}^A, c_k^A\}, \\
    Q_k^A &= Q_{k-1}^A -d_k^A + a_k.
  \end{split}
\end{equation}
The departures of the first station during period $k$ are the arrivals
at station $B$ at the end of period $k$, i.e., $a_k^B =
d_{k}^A$. Thus,
\begin{equation}
  \begin{split}
    a_k^B &= d_{k}^A,\\
    d^B_k &= \min\{Q_{k-1}^B, c_k^B\}, \\
    Q_k^B &= Q_{k-1}^B -d_k^B + a_k^B.
  \end{split}
\end{equation}
\end{solution}
\end{exercise}

\begin{exercise} (A tandem queue with blocking)
  Consider a production network with two production stations in tandem
  with blocking: when the intermediate queue, i.e., the queue in front of
  Station B, exceeds some level $M$, then station A has to stop
  producing, and when $Q^B_k < M$ station A is not allowed to produce
  more than the intermediate queue can contain. Extend the recursions
  of \eqref{eq:31} to simulate this situation.
\begin{solution}
\begin{equation}
  \begin{split}
    d^A_k &= \min\{Q_{k-1}^A, c_k^A, M-Q^B_{k-1}\}, \\
    Q_k^A &= Q_{k-1}^A -d_k^A + a_k, \\
    a_k^B &= d_{k}^A, \text{ (ensures all jobs first pass station A and then station B)}\\
    d^B_k &= \min\{Q_{k-1}^B, c_k^B\}, \\
    Q_k^B &= Q_{k-1}^B -d_k^B + a_k^B.
  \end{split}
\end{equation}
This is a bit subtle: since there is room $M-Q^B_{k-1}$ at the
intermediate buffer and $d_k^A \leq M-Q^B_{k-1}$, we know that in the
worst case, i.e., when $c_k^B=0$, still $Q^B_k = Q_{k_1}^B +
d_k^A$.
Thus, we are sure that the queue length of the intermediate queue will
not exceed $M$.

There is still  a small problem: What if for the first initial periods  $M<Q^B_{k-1}$. Then $M-Q^B_{k-1}<0$ and then by the specification above, $d_k^A < 0$. This is not what we want. Therefore, 
\begin{equation*}
  d^A_k = \min\{Q_{k-1}^A, c_k^A, \max\{M-Q^B_{k-1}, 0\}\}.
\end{equation*}
\end{solution}
\end{exercise}

\begin{exercise} (Merging departure streams)
  Consider another production situation with two machines, A and B
  say, that send their products to Station C. Derive a set of
  recursion relations to simulate this system. 
\begin{solution}
Realize that Stations A and B have their own arrivals. 
\begin{equation}
  \begin{split}
    d^A_k &= \min\{Q_{k-1}^A, c_k^A\}, \\
    Q_k^A &= Q_{k-1}^A -d_k^A + a_k^A, \\
    d^B_k &= \min\{Q_{k-1}^B, c_k^B\}, \\
    Q_k^B &= Q_{k-1}^B -d_k^B + a_k^B, \\
    a_k^C &= d_{k}^A+d_{k}^B,\\
    d^C_k &= \min\{Q_{k-1}^C, c_k^C\}, \\
    Q_k^C &= Q_{k-1}^C -d_k^C + a_k^C.
  \end{split}
\end{equation}
\end{solution}
\end{exercise}


\begin{exercise} (Merging incoming streams) 
Consider a   single-server queue that serves two customer `streams' in a FIFO
  discipline. Thus, both streams enter one queue that is served by the
  server. Let $\{a_k^a\}$ be the number of arrivals of stream $a$ in
  period $k$ and $\{a_k^b\}$ be the number of arrivals of stream
  $b$. Find a set of recursions by which it becomes possible to
  analyze the waiting time distribution of each of the streams. Assume
  that the service capacity $c$ is constant for all periods, and that
  jobs that arrive in period $k$ can also be served in period $k$.
  \begin{solution}
    The behavior of the queue length  process is easy: 
    \begin{equation*}
      \begin{split}
      d_k &= \min\{Q_{k-1}+a_k^a+a_k^b, c\}, \\
Q_k &= Q_{k-1}+a_k^a + a_k^b - d_k.
      \end{split}
    \end{equation*}

    To determine the waiting times, observe that any arrival in period
    $k$, independent of the stream, has to wait until all jobs at the
    start of the period in queue, i.e., $Q_{k-1}-d_k$, are cleared;
    note that we assume here that the jobs served in period $k$ depart
    at the start of the interval. Thus, the minimal waiting time is
    $W_{k,-} = \lfloor Q_{k-1}/c\rfloor$.  Similarly, the maximal
    waiting time is
    $W_{k,+} = \lfloor (Q_{k-1}+a_k^a + a_k^b) /c\rfloor$.

    The remaining problem is to make a model to `distribute' the
    time between $W_{k,-}$ and~$W_{k,+}$ over the two streams. 

    A simple model is to assume that the waiting time is averaged over
    the jobs. Then each job perceives a waiting time of
    \begin{equation*}
      \frac{W_{k,-} + W_{k,+}}2.
    \end{equation*}

    Another way is to give priority to $a$ customers, but only for the
    jobs that arrive in this period. (Hence, this is different from
    the priority queue. There priority customers can overtake
    customers that arrived earlier. In the present case this is not
    allowed, jobs of type $a$ that arrive in period $k$ cannot
    overtake $b$ jobs that arrived prior to period $k$.)  Making this
    completely explicit (so that the recursion can be fed to the
    computer) requires a bit of work however.  It is important to
    understand the trick we will discuss now because we will use it to
    model queueing systems with batching. Observe that the first job
    of the $a$ stream only has to wait for $W_{k,-}$, the second job
    must wait $W_{k,-}+1$, and so on. Thus, the waiting time $W_{k}^a$
    for the $a_k^a$ items is such that
    \begin{equation*}
W_{k,-}^a:= \lfloor Q_{k-1}/c \rfloor \leq  W_{k}^a \leq \lfloor (Q_{k-1}+a_k^a)/c \rfloor =: W_{k,+}^a.
    \end{equation*}
    Similarly, for the $b$ jobs must be
    \begin{equation*}
W_{k,-}^b := \lfloor (Q_{k-1}+a_k^a)/c \rfloor \leq  W_{k}^b \leq \lfloor (Q_{k-1}+a_k^a+a_k^b)/c \rfloor =: W_{k,+}^b.
    \end{equation*}
Note that $W_{k,+}^a = W_{k,-}^b$. 
It is then sensible to set 
\begin{align*}
  W_{k}^a &= \frac{W_{k,-}^a + W_{k,+}^a}2, \\
  W_{k}^b &= \frac{W_{k,-}^b + W_{k,+}^b}2.
\end{align*}

  \end{solution}
\end{exercise}



\begin{exercise} (Splitting streams)
  Consider a machine (a paint mixing machine) that produces products
  for two separate downstream machines A and B (two different paint
  packaging machines), each with its own queue.  Suppose we want to
  analyze the queue in front of station A. For this we need to know
  the arrivals to station A, that is, the departures of the mixing
  station that go to station A. Provide a set of recursions to
  simulate this system.
  \begin{solution}
\begin{enumerate}
\item Realize that the recursions of Eq~\eqref{eq:31} applied to the
  queueing situation at the first machine provide us with the total
  number of departures $d_k$ during period $k$. However, it does not
  tell us about the type of these departures. Thus, to compute the
  queue in front of station A, we need do know the number of
  departures of type A, rather than the total number of departures of
  the first station.
\item It is reasonable that the number of jobs of type $A$ in queue at
  the first station is equal to
  \begin{equation*}
  Q_k \frac{\lambda_A}{\lambda_A + \lambda_B}.
  \end{equation*}
  It is therefore reasonable to assume that the capacity $c_k$ of the
  first station is also shared in this proportion to type A and B
  jobs. Thus, the number of departures to station $A$ is
  \begin{equation*}
    d_k(A) = \frac{\lambda_A}{\lambda_A+\lambda_B} \min\left\{ Q_{k-1}, c_k\right\}.
  \end{equation*}
 The rest of the recursions is very similar to what we did in earlier exercises.
\end{enumerate}
  \end{solution}
\end{exercise}



\begin{exercise}(Inventory control) The recursions used in the
  exercises above can also be applied to analyze inventory control
  policies. Consider a production system that can produce maximally
  $M_k$ items per week during normal working hours, and maximally
  $N_k$ items during extra (weekend and evening) hours. Let, for
  period $k$,
  \begin{align*}
    D_k &= \text{Demand in  week $k$}, \\
    S_k &= \text{Sales, i.e., number of items sold, in week $k$}, \\
    r_k &= \text{Revenue per item sold in week $k$}, \\
    X_k &= \text{Number of items produced in week $k$  during normal hours}, \\
    Y_k &= \text{Number of items produced in week $k$ during extra  hours}, \\
    c_k &= \text{Production cost per item during normal  hours}, \\
    d_k &= \text{Production cost per item during extra  hours}, \\
    h_k &= \text{holding cost per  item, due at the end of week $k$}, \\
    I_k &= \text{On hand inventory level at the end of week $k$}. \\
  \end{align*}
  Management needs a production plan that specifies for the next $T$
  weeks the number of items to be produced per week. Formulate this
  problem as an LP problem, taking into account the inventory
  dynamics.  Assume that demand must be met from on-hand inventory.
  \begin{hint}
Formulate the decision variables/controls, the
    objective and the constraints.    
  \end{hint}
  \begin{solution}
    The decision variables are $X_k$, $Y_k$ and $S_k$ (note, it is not
    necessary to meet all demand:  the production cost and profit
    may vary per period.)  The objective is 
    \begin{equation*}
      \max \sum_{k=1}^T (r_kS_k -c_k X_k - d_k Y_k - h_k I_k).
    \end{equation*}
The constraints are 
\begin{align*}
  0&\leq S_k \leq D_k, \\
  0&\leq X_k \leq M_k, \\
  0&\leq Y_k \leq N_k, \\
  I_k&=I_{k-1}+X_k+Y_k - S_k. \\
I_k &\geq 0.
\end{align*}
  \end{solution}
\end{exercise}

\begin{exercise}(Queue with setups)
  One server serves two parallel queues, one at a time. After serving
   one queue until it is empty,  the server moves to the other
  queue. The change of queue requires one period setup time. (This is a tough problem; you can skip it if you don't have the time to really think about it.)
  \begin{solution}
We need an extra variable $p_k$ that specifies  which queue is being served. If $p_k=0$, the server is moving from one queue to the other, if $p=1$, the server is at queue 1, and if $p_k=2$ it is at queue $2$. Then, with
\begin{align*}
  d^1_k &= \min\{Q^1_{k-1}, c_k^1 \1{p_k=1}\}, \\
  d^2_k &= \min\{Q^2_{k-1}, c_k^2 \1{p_k=2}\},
\end{align*}
we can specify the evolution of the queue length processes. So it remains to deal with $p$. For this, we use a `truth table' to compute $p_{k+1}$ as a function of $p_k$ and whether $Q_k^1 > 0$ or not and $Q_k^2 > 0$ or not. 

\begin{tabular}{ccc|l}
  $\1{Q^1_k > 0}$ & $\1{Q_k^2 > 0}$ & $p_k$ & $p_{k+1}$ \\ \hline
0 & 0 & 0 & 0 \\
0 & 0 & 1 & 1 \\
0 & 0 & 2 & 2 \\
1 & 0 & 0 & 1 \\
1 & 0 & 1 & 1 \\
1 & 0 & 2 & 0 (switch over time)\\
0 & 1 & 0 & 2 \\
0 & 1 & 1 & 0 (switch over time)\\
0 & 1 & 2 & 2 \\
1 & 1 & 0 & 1 (to break ties) \\
1 & 1 & 1 & 1 \\
1 & 1 & 2 & 2 \\
\end{tabular}

  \end{solution}
\end{exercise}

\Closesolutionfile{hint}
\Closesolutionfile{ans}

\opt{solutionfiles}{
\subsection*{Hints}
\input{hint}
\subsection*{Solutions}
\input{ans}
}


%\clearpage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../queueing_book"
%%% End:
